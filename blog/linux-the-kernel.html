<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Miguel Bracamontes">
    <meta name="description" content="A wwweb enthusiast online space">
    <title>Miguel Bracamontes</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
	<!-- header -->
	<header class="marpad">
		<h1>Miguel Bracamontes</h1>
		<p><em>A wwweb enthusiast</em></p>
		<img src="https://images2.imgbox.com/71/7e/dJZMLjYc_o.gif">
	</header>
	<!-- navigation bar -->
	<nav class="marpad">
		<ul class="navbar">
			<li><a href="/index.html">home</a></li>
			<li><a href="/blog.html">blog</a></li>
			<li><a href="/about.html">about</a></li>
			<li><a href="/contact.html">contact</a></li>
		</ul>
	</nav>
    <!-- content -->
    <main class="marpad">
        <article>
            <section class="article-header">
                <h2>Linux the kernel</h2>
                <time>2024-03-04</time>
                <p class="marginless"><em>About Linux and technology</em></p>
            </section>
            <section>
				<p>It is common for us to refer to any operating system that uses the Linux kernel as "Linux." In reality, Linux is not an operating system in itself; it is a fundamental part for building one, though. Being only "a part" (though fundamental) means that there are many variations of operating systems, all built using many parts, each their own, but coinciding in one: the kernel.</p>
				<p>An operating system kernel is the program (the lines of code arranged to perform tasks) that communicates directly with the processor. Although some purists may point out a certain error here, I will continue nonetheless with the aim of explanation. And it's not just with the processor, but with any hardware (a piece of intelligent metal that knows how to do certain things) that lies there, with potential at rest and that is part of the computer.</p>
				<p>In the end, when one reflects on the nature of computers, one finds that they are nothing but a collection of metal sheets that we teach mathematics to and then assemble in a certain way. The iteration in the applications of that knowledge we put on the sheets led us to represent significant data through the coordinated dance of ones and zeros. We made millions of little switches suddenly let light pass, or suddenly not, and the accumulation of those actions means something to us. Whether it's a sound, music, a pixel, a color, an image, a video - all of them digital products that are at the same time cultural and human material and, on the other hand, a combination of electrical states representing symbols.</p>
				<p>So, to make those switches let light pass (or not) in a certain way, coordinated in such a way that the result is what the user expects, I must have a means of communication between the person using the machine and the metal sheets, which know very well how to do their thing, interpreting and representing, but not reading minds. Computers (the set of intelligent sheets assembled in a certain way) are pedantic machines - very pedantic. They are capable of impressive computations as long as they receive precise instructions - almost military.</p>
				<p>Something that is known is that computers have managed to simplify this process very well. Nowadays, computers come equipped with a collection of tools to satisfy practically any need that can be delegated to technology through what we now know as applications and which was previously known simply as programs. In the end, it's the same thing: the software that was written to automate (or facilitate) a task. An interface through which the user interacts (or enters instructions, clicks, text) and receives a solution (or computation, result) from the computer.</p>
				<p>The question that automatically arises at this point is what happens behind the scenes for those "applications" to communicate with the intelligent sheets and for me to receive my result? Or perhaps it's also worth asking how the hardware interacts with the software? Fortunately, the answer is the very topic of this dissertation: operating systems, including their constituent parts, including the kernel.</p>
				<p>Before continuing like this, it seems productive to me to note what I understand by an operating system. When you reduce them to their most basic minimum in order to define them, you can say that they are a bundle of programs - a more or less predefined ecosystem with certain characteristics and parameters that seeks to satisfy a specific group of needs. Clear examples of this are Windows and macOS, only because they are the most popular.</p>
				<p>If we now allow ourselves to think in terms of Windows and Mac, the comparison becomes much easier. We can talk about a clear difference both in the visual aspect and in the functional aspect. Although the purposes of each are similar, the method employed to satisfy them is different. They each have their own way of approaching the problem that is perfectly analyzable. The taskbar, the dock, the shortcuts, the method of installing programs, etc. - they are two different operating systems. Each one has a program that is a calculator, or one that is a text editor. Each operating system will offer a collection of more or less office-like programmed tools in the case of home computers. Or they can also offer other types of configurations depending on the purpose or use they seek to give to the computer. In the end, it's the same thing: operating systems are that collection of programs, windows, desktop environments (how everything looks under a branding), commands, shortcuts, etc., that users interpret as an ontological whole called "computer." But it's worth abstracting and understanding it separately.</p>
				<p>They happen simultaneously, however. They are interactions, simultaneous actions of one and the other (the computer and its operating system). On the one hand, the intelligent sheets allowing (or not) electricity to pass through their cells to store them as ones and zeros dancing. And on the other hand, that set of programs, those lines of code arranged in a certain way that, when executed in order in the style of instructions, result in an operating system - one of many.</p>
				<p>One of the programs that are a constant across most operating systems is the one that allows you to explore your files. The program that, when you open it, shows you your images, documents, downloads, music, etc. The file browser is a window to our storage disks. It is an interface that allows us to visually observe the hierarchical order adopted by the files and directories that all together constitute the sheets where the code of my operating system is written.</p>
				<p>All those tools are programs - that is, they are lines of code actually written in a document and that must lie somewhere to be accessed. All those files that constitute my programs (and everything else that I store on my disks) are organized following an established rule. "File systems" are formed so that there is a conventional order in which things will be saved so that they can later be accessed and used. So, with the file browser, we can actually observe the file system in action, even if it sounds redundant.</p>
				<p>Who determines this convention of archival arrangement? The kernel. Not only does it determine the file system (or possible selection of systems), but it is basically responsible for all the convention on which the instructions of the user and the intelligent sheets that form the computer must communicate. Why is a letter "c" written when I press the key with the "c" symbol on my keyboard? Why does the word processor return a PDF file when I clicked on its button that says "export to PDF"? Why did my printer start printing a document when I clicked on the program where it says "print"? What determines in what "language" the instructions to the computer will be given at the processor level?</p>
				<p>I am shown the operating system through the monitors. Another fundamental part of the operating system takes care of that: the desktop environment. But if I have a monitor, I can actually see my operating system. I can see the program, its window, its interface, its buttons, its colors, its different functions. I can see the text appear obeying my keystrokes. All this visual interaction and input of data that I am having with my operating system (and that I can also see) will result in a reaction from my computer. It will publish my text online, play music, save my files as I produce them, store and encrypt certain information in the form of texts and images.</p>
				<p>And each of those interactions with my metal happened in a language - in a way. My hard drives, my processor, my video card, all that intelligent metal receiving strict and detailed orders on when (and when not) to let a byte of energy pass. How long to store it. How to make the ones and zeros dance. Receiving instructions from me through buttons on my screen. The gigantic translation of buttons on the screen is equal to bits yes or no in my processor, bytes yes or no in my storage - it is the responsibility of the kernel. That fundamental part for an operating system. The kernel is the one that speaks the language of the intelligent sheets. Everything else is mere translation for the simple human (speaking figuratively, since the human wrote those kernels). Interpretations that we assemble in a machine language and that do the work of our interpreter with the pedantic computers.</p>
				<p>That, then, is Linux - an interpreter that dictates conventions so that, through it, the programs of the operating system communicate the user's instructions to the hardware. Linux is the kernel that operating system developers decide to use to, on top of it, write (or compile) a set of tools that, put together, form an operating system. Or also what in the world of Linux kernel systems is usually called a "Linux distribution." Like the one I use, for example, called Manjaro. But the philosophical details of distributions are material for another dissertation. For now, it is enough to observe that, fortunately, we recognize that Linux is not "a single operating system, difficult to understand" but a vibrant collection of many operating systems, each of which specializes in meeting a class of needs and that, due to their free and open nature, are well worth trying.</p>
            </section>
        </article>
    </main>
    <!-- footer -->
	<footer class="marpad">
		<p>&copy; 2024 Miguel Bracamontes</p>
		<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noreferrer"><img src="https://images2.imgbox.com/a5/42/IV9saTzo_o.png"></a>
	</footer>
    <!-- scripts -->
    <script src="script.js"></script>
</body>
</html>